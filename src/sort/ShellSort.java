package sort;
/**
 * @time 17.8.25
 * @author 高伟鹏
 * @description 希尔排序简写
 */
public class ShellSort {
    /*原数组：   9 3 5 1 6 7 8 4 数组长度为8
     * 算法思想： 第一次比较，比较宽度为数组长度除2   9 3 5 1 6 7 8 4  此数组第一次宽度为4
     *                                  | | | | | | | |
     *                                  6 | | | 9 | | |  第1个数与第5个数为1个新的数组（第9个数不存在），进行直接插入排序，得到前面序列
     *                                    3 | |   7 | |  第2个数与第6个数为1个新的数组（第10个数不存在），进行直接插入排序，得到前面序列
     *                                      5 |     8 |  第3个数与第7个数为1个新的数组（第11个数不存在），进行直接插入排序，得到前面序列
     *                                        1       4  第4个数与第8个数为1个新的数组（第12个数不存在），进行直接插入排序，得到前面序列
     *                 经过第一次排序得到             6 3 5 1 9 7 8 4   
     *                    
     *         第二次比较宽度为上一次宽度除2     6 3 5 1 9 7 8 4  此此比较宽度为2
     *                                  | | | | | | | |
     *                                  5 | 6 | 8 | 9 |  第1个数，第3个数，第5个数，第7个数为1个新的数组（第9个数不存在），进行直接插入排序，得到前面序列
     *                                    1   3   4   7  第2个数，第4个数，第6个数，第8个数为1个新的数组（第10个数不存在），进行直接插入排序，得到前面序列
     *                 经过第二次排序得到             5 1 6 3 8 4 9 7   
     *                 
     *         第三次比较宽度为1             5 1 6 3 8 4 9 7  
     *                                  | | | | | | | |
     *                                  1 3 4 5 6 7 8 9  因为比较宽度为1，直接将数组进行直接插入排序，得到前面序列   
     */
	public static int[] shellSort(int[] array){
		if(array.length>0){
			for(int distance = array.length >> 1; distance >= 1; distance = distance>>1){//distance为每次比较的宽度，根据distance来划分新的数组
				int i=0,j=0,temp=0,condition=0;
				condition = array.length;  //从此处代码开始为直接插入排序算法，将所有的1，换成了distance，模拟新数组
				for(i = distance;i<condition;i+=distance){
					temp = array[i];//记录下此次循环的初始比较值
					for(j=i-distance;j>=0&&array[j]>temp;j-=distance){//如果前一个元素大于待比较元素，则将前一个元素元素放到它后一个位置上
							array[j+distance] = array[j];
					}//循环结束得到第一个不大于带比较元素的位置j;
					array[j+distance] = temp;//将带比较元素赋值给第j个位置的元素，完成一次循环
				}
			}
		}
		return array;
	}
}
